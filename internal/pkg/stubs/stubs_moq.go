// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package stubs

import (
	"context"
	"github.com/go-kratos/kratos/v2/log"
	"gopkg.in/alexcesaro/statsd.v2"
	"sync"
)

// Ensure, that MetricsMock does implement Metrics.
// If this is not the case, regenerate this file with moq.
var _ Metrics = &MetricsMock{}

// MetricsMock is a mock implementation of Metrics.
//
//	func TestSomethingThatUsesMetrics(t *testing.T) {
//
//		// make and configure a mocked Metrics
//		mockedMetrics := &MetricsMock{
//			CloseFunc: func()  {
//				panic("mock out the Close method")
//			},
//			CountFunc: func(bucket string, n interface{})  {
//				panic("mock out the Count method")
//			},
//			GaugeFunc: func(bucket string, value interface{})  {
//				panic("mock out the Gauge method")
//			},
//			HistogramFunc: func(bucket string, value interface{})  {
//				panic("mock out the Histogram method")
//			},
//			IncrementFunc: func(bucket string)  {
//				panic("mock out the Increment method")
//			},
//			NewTimingFunc: func() statsd.Timing {
//				panic("mock out the NewTiming method")
//			},
//			TimingFunc: func(bucket string, value interface{})  {
//				panic("mock out the Timing method")
//			},
//		}
//
//		// use mockedMetrics in code that requires Metrics
//		// and then make assertions.
//
//	}
type MetricsMock struct {
	// CloseFunc mocks the Close method.
	CloseFunc func()

	// CountFunc mocks the Count method.
	CountFunc func(bucket string, n interface{})

	// GaugeFunc mocks the Gauge method.
	GaugeFunc func(bucket string, value interface{})

	// HistogramFunc mocks the Histogram method.
	HistogramFunc func(bucket string, value interface{})

	// IncrementFunc mocks the Increment method.
	IncrementFunc func(bucket string)

	// NewTimingFunc mocks the NewTiming method.
	NewTimingFunc func() statsd.Timing

	// TimingFunc mocks the Timing method.
	TimingFunc func(bucket string, value interface{})

	// calls tracks calls to the methods.
	calls struct {
		// Close holds details about calls to the Close method.
		Close []struct {
		}
		// Count holds details about calls to the Count method.
		Count []struct {
			// Bucket is the bucket argument value.
			Bucket string
			// N is the n argument value.
			N interface{}
		}
		// Gauge holds details about calls to the Gauge method.
		Gauge []struct {
			// Bucket is the bucket argument value.
			Bucket string
			// Value is the value argument value.
			Value interface{}
		}
		// Histogram holds details about calls to the Histogram method.
		Histogram []struct {
			// Bucket is the bucket argument value.
			Bucket string
			// Value is the value argument value.
			Value interface{}
		}
		// Increment holds details about calls to the Increment method.
		Increment []struct {
			// Bucket is the bucket argument value.
			Bucket string
		}
		// NewTiming holds details about calls to the NewTiming method.
		NewTiming []struct {
		}
		// Timing holds details about calls to the Timing method.
		Timing []struct {
			// Bucket is the bucket argument value.
			Bucket string
			// Value is the value argument value.
			Value interface{}
		}
	}
	lockClose     sync.RWMutex
	lockCount     sync.RWMutex
	lockGauge     sync.RWMutex
	lockHistogram sync.RWMutex
	lockIncrement sync.RWMutex
	lockNewTiming sync.RWMutex
	lockTiming    sync.RWMutex
}

// Close calls CloseFunc.
func (mock *MetricsMock) Close() {
	callInfo := struct {
	}{}
	mock.lockClose.Lock()
	mock.calls.Close = append(mock.calls.Close, callInfo)
	mock.lockClose.Unlock()
	if mock.CloseFunc == nil {
		return
	}
	mock.CloseFunc()
}

// CloseCalls gets all the calls that were made to Close.
// Check the length with:
//
//	len(mockedMetrics.CloseCalls())
func (mock *MetricsMock) CloseCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockClose.RLock()
	calls = mock.calls.Close
	mock.lockClose.RUnlock()
	return calls
}

// Count calls CountFunc.
func (mock *MetricsMock) Count(bucket string, n interface{}) {
	callInfo := struct {
		Bucket string
		N      interface{}
	}{
		Bucket: bucket,
		N:      n,
	}
	mock.lockCount.Lock()
	mock.calls.Count = append(mock.calls.Count, callInfo)
	mock.lockCount.Unlock()
	if mock.CountFunc == nil {
		return
	}
	mock.CountFunc(bucket, n)
}

// CountCalls gets all the calls that were made to Count.
// Check the length with:
//
//	len(mockedMetrics.CountCalls())
func (mock *MetricsMock) CountCalls() []struct {
	Bucket string
	N      interface{}
} {
	var calls []struct {
		Bucket string
		N      interface{}
	}
	mock.lockCount.RLock()
	calls = mock.calls.Count
	mock.lockCount.RUnlock()
	return calls
}

// Gauge calls GaugeFunc.
func (mock *MetricsMock) Gauge(bucket string, value interface{}) {
	callInfo := struct {
		Bucket string
		Value  interface{}
	}{
		Bucket: bucket,
		Value:  value,
	}
	mock.lockGauge.Lock()
	mock.calls.Gauge = append(mock.calls.Gauge, callInfo)
	mock.lockGauge.Unlock()
	if mock.GaugeFunc == nil {
		return
	}
	mock.GaugeFunc(bucket, value)
}

// GaugeCalls gets all the calls that were made to Gauge.
// Check the length with:
//
//	len(mockedMetrics.GaugeCalls())
func (mock *MetricsMock) GaugeCalls() []struct {
	Bucket string
	Value  interface{}
} {
	var calls []struct {
		Bucket string
		Value  interface{}
	}
	mock.lockGauge.RLock()
	calls = mock.calls.Gauge
	mock.lockGauge.RUnlock()
	return calls
}

// Histogram calls HistogramFunc.
func (mock *MetricsMock) Histogram(bucket string, value interface{}) {
	callInfo := struct {
		Bucket string
		Value  interface{}
	}{
		Bucket: bucket,
		Value:  value,
	}
	mock.lockHistogram.Lock()
	mock.calls.Histogram = append(mock.calls.Histogram, callInfo)
	mock.lockHistogram.Unlock()
	if mock.HistogramFunc == nil {
		return
	}
	mock.HistogramFunc(bucket, value)
}

// HistogramCalls gets all the calls that were made to Histogram.
// Check the length with:
//
//	len(mockedMetrics.HistogramCalls())
func (mock *MetricsMock) HistogramCalls() []struct {
	Bucket string
	Value  interface{}
} {
	var calls []struct {
		Bucket string
		Value  interface{}
	}
	mock.lockHistogram.RLock()
	calls = mock.calls.Histogram
	mock.lockHistogram.RUnlock()
	return calls
}

// Increment calls IncrementFunc.
func (mock *MetricsMock) Increment(bucket string) {
	callInfo := struct {
		Bucket string
	}{
		Bucket: bucket,
	}
	mock.lockIncrement.Lock()
	mock.calls.Increment = append(mock.calls.Increment, callInfo)
	mock.lockIncrement.Unlock()
	if mock.IncrementFunc == nil {
		return
	}
	mock.IncrementFunc(bucket)
}

// IncrementCalls gets all the calls that were made to Increment.
// Check the length with:
//
//	len(mockedMetrics.IncrementCalls())
func (mock *MetricsMock) IncrementCalls() []struct {
	Bucket string
} {
	var calls []struct {
		Bucket string
	}
	mock.lockIncrement.RLock()
	calls = mock.calls.Increment
	mock.lockIncrement.RUnlock()
	return calls
}

// NewTiming calls NewTimingFunc.
func (mock *MetricsMock) NewTiming() statsd.Timing {
	callInfo := struct {
	}{}
	mock.lockNewTiming.Lock()
	mock.calls.NewTiming = append(mock.calls.NewTiming, callInfo)
	mock.lockNewTiming.Unlock()
	if mock.NewTimingFunc == nil {
		var (
			timingOut statsd.Timing
		)
		return timingOut
	}
	return mock.NewTimingFunc()
}

// NewTimingCalls gets all the calls that were made to NewTiming.
// Check the length with:
//
//	len(mockedMetrics.NewTimingCalls())
func (mock *MetricsMock) NewTimingCalls() []struct {
} {
	var calls []struct {
	}
	mock.lockNewTiming.RLock()
	calls = mock.calls.NewTiming
	mock.lockNewTiming.RUnlock()
	return calls
}

// Timing calls TimingFunc.
func (mock *MetricsMock) Timing(bucket string, value interface{}) {
	callInfo := struct {
		Bucket string
		Value  interface{}
	}{
		Bucket: bucket,
		Value:  value,
	}
	mock.lockTiming.Lock()
	mock.calls.Timing = append(mock.calls.Timing, callInfo)
	mock.lockTiming.Unlock()
	if mock.TimingFunc == nil {
		return
	}
	mock.TimingFunc(bucket, value)
}

// TimingCalls gets all the calls that were made to Timing.
// Check the length with:
//
//	len(mockedMetrics.TimingCalls())
func (mock *MetricsMock) TimingCalls() []struct {
	Bucket string
	Value  interface{}
} {
	var calls []struct {
		Bucket string
		Value  interface{}
	}
	mock.lockTiming.RLock()
	calls = mock.calls.Timing
	mock.lockTiming.RUnlock()
	return calls
}

// Ensure, that LoggerMock does implement Logger.
// If this is not the case, regenerate this file with moq.
var _ Logger = &LoggerMock{}

// LoggerMock is a mock implementation of Logger.
//
//	func TestSomethingThatUsesLogger(t *testing.T) {
//
//		// make and configure a mocked Logger
//		mockedLogger := &LoggerMock{
//			DebugFunc: func(a ...interface{})  {
//				panic("mock out the Debug method")
//			},
//			DebugfFunc: func(format string, a ...interface{})  {
//				panic("mock out the Debugf method")
//			},
//			DebugwFunc: func(keyvals ...interface{})  {
//				panic("mock out the Debugw method")
//			},
//			ErrorFunc: func(a ...interface{})  {
//				panic("mock out the Error method")
//			},
//			ErrorfFunc: func(format string, a ...interface{})  {
//				panic("mock out the Errorf method")
//			},
//			ErrorwFunc: func(keyvals ...interface{})  {
//				panic("mock out the Errorw method")
//			},
//			FatalFunc: func(a ...interface{})  {
//				panic("mock out the Fatal method")
//			},
//			FatalfFunc: func(format string, a ...interface{})  {
//				panic("mock out the Fatalf method")
//			},
//			FatalwFunc: func(keyvals ...interface{})  {
//				panic("mock out the Fatalw method")
//			},
//			InfoFunc: func(a ...interface{})  {
//				panic("mock out the Info method")
//			},
//			InfofFunc: func(format string, a ...interface{})  {
//				panic("mock out the Infof method")
//			},
//			InfowFunc: func(keyvals ...interface{})  {
//				panic("mock out the Infow method")
//			},
//			LogFunc: func(level log.Level, keyvals ...interface{})  {
//				panic("mock out the Log method")
//			},
//			WarnFunc: func(a ...interface{})  {
//				panic("mock out the Warn method")
//			},
//			WarnfFunc: func(format string, a ...interface{})  {
//				panic("mock out the Warnf method")
//			},
//			WarnwFunc: func(keyvals ...interface{})  {
//				panic("mock out the Warnw method")
//			},
//			WithContextFunc: func(ctx context.Context) *log.Helper {
//				panic("mock out the WithContext method")
//			},
//		}
//
//		// use mockedLogger in code that requires Logger
//		// and then make assertions.
//
//	}
type LoggerMock struct {
	// DebugFunc mocks the Debug method.
	DebugFunc func(a ...interface{})

	// DebugfFunc mocks the Debugf method.
	DebugfFunc func(format string, a ...interface{})

	// DebugwFunc mocks the Debugw method.
	DebugwFunc func(keyvals ...interface{})

	// ErrorFunc mocks the Error method.
	ErrorFunc func(a ...interface{})

	// ErrorfFunc mocks the Errorf method.
	ErrorfFunc func(format string, a ...interface{})

	// ErrorwFunc mocks the Errorw method.
	ErrorwFunc func(keyvals ...interface{})

	// FatalFunc mocks the Fatal method.
	FatalFunc func(a ...interface{})

	// FatalfFunc mocks the Fatalf method.
	FatalfFunc func(format string, a ...interface{})

	// FatalwFunc mocks the Fatalw method.
	FatalwFunc func(keyvals ...interface{})

	// InfoFunc mocks the Info method.
	InfoFunc func(a ...interface{})

	// InfofFunc mocks the Infof method.
	InfofFunc func(format string, a ...interface{})

	// InfowFunc mocks the Infow method.
	InfowFunc func(keyvals ...interface{})

	// LogFunc mocks the Log method.
	LogFunc func(level log.Level, keyvals ...interface{})

	// WarnFunc mocks the Warn method.
	WarnFunc func(a ...interface{})

	// WarnfFunc mocks the Warnf method.
	WarnfFunc func(format string, a ...interface{})

	// WarnwFunc mocks the Warnw method.
	WarnwFunc func(keyvals ...interface{})

	// WithContextFunc mocks the WithContext method.
	WithContextFunc func(ctx context.Context) *log.Helper

	// calls tracks calls to the methods.
	calls struct {
		// Debug holds details about calls to the Debug method.
		Debug []struct {
			// A is the a argument value.
			A []interface{}
		}
		// Debugf holds details about calls to the Debugf method.
		Debugf []struct {
			// Format is the format argument value.
			Format string
			// A is the a argument value.
			A []interface{}
		}
		// Debugw holds details about calls to the Debugw method.
		Debugw []struct {
			// Keyvals is the keyvals argument value.
			Keyvals []interface{}
		}
		// Error holds details about calls to the Error method.
		Error []struct {
			// A is the a argument value.
			A []interface{}
		}
		// Errorf holds details about calls to the Errorf method.
		Errorf []struct {
			// Format is the format argument value.
			Format string
			// A is the a argument value.
			A []interface{}
		}
		// Errorw holds details about calls to the Errorw method.
		Errorw []struct {
			// Keyvals is the keyvals argument value.
			Keyvals []interface{}
		}
		// Fatal holds details about calls to the Fatal method.
		Fatal []struct {
			// A is the a argument value.
			A []interface{}
		}
		// Fatalf holds details about calls to the Fatalf method.
		Fatalf []struct {
			// Format is the format argument value.
			Format string
			// A is the a argument value.
			A []interface{}
		}
		// Fatalw holds details about calls to the Fatalw method.
		Fatalw []struct {
			// Keyvals is the keyvals argument value.
			Keyvals []interface{}
		}
		// Info holds details about calls to the Info method.
		Info []struct {
			// A is the a argument value.
			A []interface{}
		}
		// Infof holds details about calls to the Infof method.
		Infof []struct {
			// Format is the format argument value.
			Format string
			// A is the a argument value.
			A []interface{}
		}
		// Infow holds details about calls to the Infow method.
		Infow []struct {
			// Keyvals is the keyvals argument value.
			Keyvals []interface{}
		}
		// Log holds details about calls to the Log method.
		Log []struct {
			// Level is the level argument value.
			Level log.Level
			// Keyvals is the keyvals argument value.
			Keyvals []interface{}
		}
		// Warn holds details about calls to the Warn method.
		Warn []struct {
			// A is the a argument value.
			A []interface{}
		}
		// Warnf holds details about calls to the Warnf method.
		Warnf []struct {
			// Format is the format argument value.
			Format string
			// A is the a argument value.
			A []interface{}
		}
		// Warnw holds details about calls to the Warnw method.
		Warnw []struct {
			// Keyvals is the keyvals argument value.
			Keyvals []interface{}
		}
		// WithContext holds details about calls to the WithContext method.
		WithContext []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
	}
	lockDebug       sync.RWMutex
	lockDebugf      sync.RWMutex
	lockDebugw      sync.RWMutex
	lockError       sync.RWMutex
	lockErrorf      sync.RWMutex
	lockErrorw      sync.RWMutex
	lockFatal       sync.RWMutex
	lockFatalf      sync.RWMutex
	lockFatalw      sync.RWMutex
	lockInfo        sync.RWMutex
	lockInfof       sync.RWMutex
	lockInfow       sync.RWMutex
	lockLog         sync.RWMutex
	lockWarn        sync.RWMutex
	lockWarnf       sync.RWMutex
	lockWarnw       sync.RWMutex
	lockWithContext sync.RWMutex
}

// Debug calls DebugFunc.
func (mock *LoggerMock) Debug(a ...interface{}) {
	callInfo := struct {
		A []interface{}
	}{
		A: a,
	}
	mock.lockDebug.Lock()
	mock.calls.Debug = append(mock.calls.Debug, callInfo)
	mock.lockDebug.Unlock()
	if mock.DebugFunc == nil {
		return
	}
	mock.DebugFunc(a...)
}

// DebugCalls gets all the calls that were made to Debug.
// Check the length with:
//
//	len(mockedLogger.DebugCalls())
func (mock *LoggerMock) DebugCalls() []struct {
	A []interface{}
} {
	var calls []struct {
		A []interface{}
	}
	mock.lockDebug.RLock()
	calls = mock.calls.Debug
	mock.lockDebug.RUnlock()
	return calls
}

// Debugf calls DebugfFunc.
func (mock *LoggerMock) Debugf(format string, a ...interface{}) {
	callInfo := struct {
		Format string
		A      []interface{}
	}{
		Format: format,
		A:      a,
	}
	mock.lockDebugf.Lock()
	mock.calls.Debugf = append(mock.calls.Debugf, callInfo)
	mock.lockDebugf.Unlock()
	if mock.DebugfFunc == nil {
		return
	}
	mock.DebugfFunc(format, a...)
}

// DebugfCalls gets all the calls that were made to Debugf.
// Check the length with:
//
//	len(mockedLogger.DebugfCalls())
func (mock *LoggerMock) DebugfCalls() []struct {
	Format string
	A      []interface{}
} {
	var calls []struct {
		Format string
		A      []interface{}
	}
	mock.lockDebugf.RLock()
	calls = mock.calls.Debugf
	mock.lockDebugf.RUnlock()
	return calls
}

// Debugw calls DebugwFunc.
func (mock *LoggerMock) Debugw(keyvals ...interface{}) {
	callInfo := struct {
		Keyvals []interface{}
	}{
		Keyvals: keyvals,
	}
	mock.lockDebugw.Lock()
	mock.calls.Debugw = append(mock.calls.Debugw, callInfo)
	mock.lockDebugw.Unlock()
	if mock.DebugwFunc == nil {
		return
	}
	mock.DebugwFunc(keyvals...)
}

// DebugwCalls gets all the calls that were made to Debugw.
// Check the length with:
//
//	len(mockedLogger.DebugwCalls())
func (mock *LoggerMock) DebugwCalls() []struct {
	Keyvals []interface{}
} {
	var calls []struct {
		Keyvals []interface{}
	}
	mock.lockDebugw.RLock()
	calls = mock.calls.Debugw
	mock.lockDebugw.RUnlock()
	return calls
}

// Error calls ErrorFunc.
func (mock *LoggerMock) Error(a ...interface{}) {
	callInfo := struct {
		A []interface{}
	}{
		A: a,
	}
	mock.lockError.Lock()
	mock.calls.Error = append(mock.calls.Error, callInfo)
	mock.lockError.Unlock()
	if mock.ErrorFunc == nil {
		return
	}
	mock.ErrorFunc(a...)
}

// ErrorCalls gets all the calls that were made to Error.
// Check the length with:
//
//	len(mockedLogger.ErrorCalls())
func (mock *LoggerMock) ErrorCalls() []struct {
	A []interface{}
} {
	var calls []struct {
		A []interface{}
	}
	mock.lockError.RLock()
	calls = mock.calls.Error
	mock.lockError.RUnlock()
	return calls
}

// Errorf calls ErrorfFunc.
func (mock *LoggerMock) Errorf(format string, a ...interface{}) {
	callInfo := struct {
		Format string
		A      []interface{}
	}{
		Format: format,
		A:      a,
	}
	mock.lockErrorf.Lock()
	mock.calls.Errorf = append(mock.calls.Errorf, callInfo)
	mock.lockErrorf.Unlock()
	if mock.ErrorfFunc == nil {
		return
	}
	mock.ErrorfFunc(format, a...)
}

// ErrorfCalls gets all the calls that were made to Errorf.
// Check the length with:
//
//	len(mockedLogger.ErrorfCalls())
func (mock *LoggerMock) ErrorfCalls() []struct {
	Format string
	A      []interface{}
} {
	var calls []struct {
		Format string
		A      []interface{}
	}
	mock.lockErrorf.RLock()
	calls = mock.calls.Errorf
	mock.lockErrorf.RUnlock()
	return calls
}

// Errorw calls ErrorwFunc.
func (mock *LoggerMock) Errorw(keyvals ...interface{}) {
	callInfo := struct {
		Keyvals []interface{}
	}{
		Keyvals: keyvals,
	}
	mock.lockErrorw.Lock()
	mock.calls.Errorw = append(mock.calls.Errorw, callInfo)
	mock.lockErrorw.Unlock()
	if mock.ErrorwFunc == nil {
		return
	}
	mock.ErrorwFunc(keyvals...)
}

// ErrorwCalls gets all the calls that were made to Errorw.
// Check the length with:
//
//	len(mockedLogger.ErrorwCalls())
func (mock *LoggerMock) ErrorwCalls() []struct {
	Keyvals []interface{}
} {
	var calls []struct {
		Keyvals []interface{}
	}
	mock.lockErrorw.RLock()
	calls = mock.calls.Errorw
	mock.lockErrorw.RUnlock()
	return calls
}

// Fatal calls FatalFunc.
func (mock *LoggerMock) Fatal(a ...interface{}) {
	callInfo := struct {
		A []interface{}
	}{
		A: a,
	}
	mock.lockFatal.Lock()
	mock.calls.Fatal = append(mock.calls.Fatal, callInfo)
	mock.lockFatal.Unlock()
	if mock.FatalFunc == nil {
		return
	}
	mock.FatalFunc(a...)
}

// FatalCalls gets all the calls that were made to Fatal.
// Check the length with:
//
//	len(mockedLogger.FatalCalls())
func (mock *LoggerMock) FatalCalls() []struct {
	A []interface{}
} {
	var calls []struct {
		A []interface{}
	}
	mock.lockFatal.RLock()
	calls = mock.calls.Fatal
	mock.lockFatal.RUnlock()
	return calls
}

// Fatalf calls FatalfFunc.
func (mock *LoggerMock) Fatalf(format string, a ...interface{}) {
	callInfo := struct {
		Format string
		A      []interface{}
	}{
		Format: format,
		A:      a,
	}
	mock.lockFatalf.Lock()
	mock.calls.Fatalf = append(mock.calls.Fatalf, callInfo)
	mock.lockFatalf.Unlock()
	if mock.FatalfFunc == nil {
		return
	}
	mock.FatalfFunc(format, a...)
}

// FatalfCalls gets all the calls that were made to Fatalf.
// Check the length with:
//
//	len(mockedLogger.FatalfCalls())
func (mock *LoggerMock) FatalfCalls() []struct {
	Format string
	A      []interface{}
} {
	var calls []struct {
		Format string
		A      []interface{}
	}
	mock.lockFatalf.RLock()
	calls = mock.calls.Fatalf
	mock.lockFatalf.RUnlock()
	return calls
}

// Fatalw calls FatalwFunc.
func (mock *LoggerMock) Fatalw(keyvals ...interface{}) {
	callInfo := struct {
		Keyvals []interface{}
	}{
		Keyvals: keyvals,
	}
	mock.lockFatalw.Lock()
	mock.calls.Fatalw = append(mock.calls.Fatalw, callInfo)
	mock.lockFatalw.Unlock()
	if mock.FatalwFunc == nil {
		return
	}
	mock.FatalwFunc(keyvals...)
}

// FatalwCalls gets all the calls that were made to Fatalw.
// Check the length with:
//
//	len(mockedLogger.FatalwCalls())
func (mock *LoggerMock) FatalwCalls() []struct {
	Keyvals []interface{}
} {
	var calls []struct {
		Keyvals []interface{}
	}
	mock.lockFatalw.RLock()
	calls = mock.calls.Fatalw
	mock.lockFatalw.RUnlock()
	return calls
}

// Info calls InfoFunc.
func (mock *LoggerMock) Info(a ...interface{}) {
	callInfo := struct {
		A []interface{}
	}{
		A: a,
	}
	mock.lockInfo.Lock()
	mock.calls.Info = append(mock.calls.Info, callInfo)
	mock.lockInfo.Unlock()
	if mock.InfoFunc == nil {
		return
	}
	mock.InfoFunc(a...)
}

// InfoCalls gets all the calls that were made to Info.
// Check the length with:
//
//	len(mockedLogger.InfoCalls())
func (mock *LoggerMock) InfoCalls() []struct {
	A []interface{}
} {
	var calls []struct {
		A []interface{}
	}
	mock.lockInfo.RLock()
	calls = mock.calls.Info
	mock.lockInfo.RUnlock()
	return calls
}

// Infof calls InfofFunc.
func (mock *LoggerMock) Infof(format string, a ...interface{}) {
	callInfo := struct {
		Format string
		A      []interface{}
	}{
		Format: format,
		A:      a,
	}
	mock.lockInfof.Lock()
	mock.calls.Infof = append(mock.calls.Infof, callInfo)
	mock.lockInfof.Unlock()
	if mock.InfofFunc == nil {
		return
	}
	mock.InfofFunc(format, a...)
}

// InfofCalls gets all the calls that were made to Infof.
// Check the length with:
//
//	len(mockedLogger.InfofCalls())
func (mock *LoggerMock) InfofCalls() []struct {
	Format string
	A      []interface{}
} {
	var calls []struct {
		Format string
		A      []interface{}
	}
	mock.lockInfof.RLock()
	calls = mock.calls.Infof
	mock.lockInfof.RUnlock()
	return calls
}

// Infow calls InfowFunc.
func (mock *LoggerMock) Infow(keyvals ...interface{}) {
	callInfo := struct {
		Keyvals []interface{}
	}{
		Keyvals: keyvals,
	}
	mock.lockInfow.Lock()
	mock.calls.Infow = append(mock.calls.Infow, callInfo)
	mock.lockInfow.Unlock()
	if mock.InfowFunc == nil {
		return
	}
	mock.InfowFunc(keyvals...)
}

// InfowCalls gets all the calls that were made to Infow.
// Check the length with:
//
//	len(mockedLogger.InfowCalls())
func (mock *LoggerMock) InfowCalls() []struct {
	Keyvals []interface{}
} {
	var calls []struct {
		Keyvals []interface{}
	}
	mock.lockInfow.RLock()
	calls = mock.calls.Infow
	mock.lockInfow.RUnlock()
	return calls
}

// Log calls LogFunc.
func (mock *LoggerMock) Log(level log.Level, keyvals ...interface{}) {
	callInfo := struct {
		Level   log.Level
		Keyvals []interface{}
	}{
		Level:   level,
		Keyvals: keyvals,
	}
	mock.lockLog.Lock()
	mock.calls.Log = append(mock.calls.Log, callInfo)
	mock.lockLog.Unlock()
	if mock.LogFunc == nil {
		return
	}
	mock.LogFunc(level, keyvals...)
}

// LogCalls gets all the calls that were made to Log.
// Check the length with:
//
//	len(mockedLogger.LogCalls())
func (mock *LoggerMock) LogCalls() []struct {
	Level   log.Level
	Keyvals []interface{}
} {
	var calls []struct {
		Level   log.Level
		Keyvals []interface{}
	}
	mock.lockLog.RLock()
	calls = mock.calls.Log
	mock.lockLog.RUnlock()
	return calls
}

// Warn calls WarnFunc.
func (mock *LoggerMock) Warn(a ...interface{}) {
	callInfo := struct {
		A []interface{}
	}{
		A: a,
	}
	mock.lockWarn.Lock()
	mock.calls.Warn = append(mock.calls.Warn, callInfo)
	mock.lockWarn.Unlock()
	if mock.WarnFunc == nil {
		return
	}
	mock.WarnFunc(a...)
}

// WarnCalls gets all the calls that were made to Warn.
// Check the length with:
//
//	len(mockedLogger.WarnCalls())
func (mock *LoggerMock) WarnCalls() []struct {
	A []interface{}
} {
	var calls []struct {
		A []interface{}
	}
	mock.lockWarn.RLock()
	calls = mock.calls.Warn
	mock.lockWarn.RUnlock()
	return calls
}

// Warnf calls WarnfFunc.
func (mock *LoggerMock) Warnf(format string, a ...interface{}) {
	callInfo := struct {
		Format string
		A      []interface{}
	}{
		Format: format,
		A:      a,
	}
	mock.lockWarnf.Lock()
	mock.calls.Warnf = append(mock.calls.Warnf, callInfo)
	mock.lockWarnf.Unlock()
	if mock.WarnfFunc == nil {
		return
	}
	mock.WarnfFunc(format, a...)
}

// WarnfCalls gets all the calls that were made to Warnf.
// Check the length with:
//
//	len(mockedLogger.WarnfCalls())
func (mock *LoggerMock) WarnfCalls() []struct {
	Format string
	A      []interface{}
} {
	var calls []struct {
		Format string
		A      []interface{}
	}
	mock.lockWarnf.RLock()
	calls = mock.calls.Warnf
	mock.lockWarnf.RUnlock()
	return calls
}

// Warnw calls WarnwFunc.
func (mock *LoggerMock) Warnw(keyvals ...interface{}) {
	callInfo := struct {
		Keyvals []interface{}
	}{
		Keyvals: keyvals,
	}
	mock.lockWarnw.Lock()
	mock.calls.Warnw = append(mock.calls.Warnw, callInfo)
	mock.lockWarnw.Unlock()
	if mock.WarnwFunc == nil {
		return
	}
	mock.WarnwFunc(keyvals...)
}

// WarnwCalls gets all the calls that were made to Warnw.
// Check the length with:
//
//	len(mockedLogger.WarnwCalls())
func (mock *LoggerMock) WarnwCalls() []struct {
	Keyvals []interface{}
} {
	var calls []struct {
		Keyvals []interface{}
	}
	mock.lockWarnw.RLock()
	calls = mock.calls.Warnw
	mock.lockWarnw.RUnlock()
	return calls
}

// WithContext calls WithContextFunc.
func (mock *LoggerMock) WithContext(ctx context.Context) *log.Helper {
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockWithContext.Lock()
	mock.calls.WithContext = append(mock.calls.WithContext, callInfo)
	mock.lockWithContext.Unlock()
	if mock.WithContextFunc == nil {
		var (
			helperOut *log.Helper
		)
		return helperOut
	}
	return mock.WithContextFunc(ctx)
}

// WithContextCalls gets all the calls that were made to WithContext.
// Check the length with:
//
//	len(mockedLogger.WithContextCalls())
func (mock *LoggerMock) WithContextCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockWithContext.RLock()
	calls = mock.calls.WithContext
	mock.lockWithContext.RUnlock()
	return calls
}

// Ensure, that LoggerBaseMock does implement LoggerBase.
// If this is not the case, regenerate this file with moq.
var _ LoggerBase = &LoggerBaseMock{}

// LoggerBaseMock is a mock implementation of LoggerBase.
//
//	func TestSomethingThatUsesLoggerBase(t *testing.T) {
//
//		// make and configure a mocked LoggerBase
//		mockedLoggerBase := &LoggerBaseMock{
//			LogFunc: func(level log.Level, keyvals ...interface{}) error {
//				panic("mock out the Log method")
//			},
//		}
//
//		// use mockedLoggerBase in code that requires LoggerBase
//		// and then make assertions.
//
//	}
type LoggerBaseMock struct {
	// LogFunc mocks the Log method.
	LogFunc func(level log.Level, keyvals ...interface{}) error

	// calls tracks calls to the methods.
	calls struct {
		// Log holds details about calls to the Log method.
		Log []struct {
			// Level is the level argument value.
			Level log.Level
			// Keyvals is the keyvals argument value.
			Keyvals []interface{}
		}
	}
	lockLog sync.RWMutex
}

// Log calls LogFunc.
func (mock *LoggerBaseMock) Log(level log.Level, keyvals ...interface{}) error {
	callInfo := struct {
		Level   log.Level
		Keyvals []interface{}
	}{
		Level:   level,
		Keyvals: keyvals,
	}
	mock.lockLog.Lock()
	mock.calls.Log = append(mock.calls.Log, callInfo)
	mock.lockLog.Unlock()
	if mock.LogFunc == nil {
		var (
			errOut error
		)
		return errOut
	}
	return mock.LogFunc(level, keyvals...)
}

// LogCalls gets all the calls that were made to Log.
// Check the length with:
//
//	len(mockedLoggerBase.LogCalls())
func (mock *LoggerBaseMock) LogCalls() []struct {
	Level   log.Level
	Keyvals []interface{}
} {
	var calls []struct {
		Level   log.Level
		Keyvals []interface{}
	}
	mock.lockLog.RLock()
	calls = mock.calls.Log
	mock.lockLog.RUnlock()
	return calls
}
